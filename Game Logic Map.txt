Stage 1:

    >> If the user ever presses skip, go back to the beginning (do not touch the score value)

First, we have a save_file object with the following variables:

    * Current stage (number)
    * Current level (number)
        - This gets auto-selected when the page loads

    * Theme state (dark theme active, or no?)

    * All level information
        - Format string
        - The tagline / description / info
        - Highest score acheived
        - Passed / Not passed / Not even tried

    * Current score (for this level)
        - Note that this variable is manually reset whenever the user clicks to another level. This way, browser crashes should hopefully retain their score.
    * Highest score (for this level)


Also, there is are a few consolidation points for variables.
    * The `save_file` object stores variables that are remembered between refreshes / runs.
        - Actually "__appdata__" stores the data that is saved between sessions. "save_file" just provides methods for doing so.
        - The entire object is saved under a unique key (UUID)
        - This object also has builtin functions to save and retrieve values.
    * the `elements` object stores all the elements in the document that may need to be constantly referenced. This way, queries are cached.
        - Relies on __selectors (for maintainability's sake)
        - On program load, this is simply an object that stores strings
        - When the initialization routine is called, this object is transformed to containing the actual DOM objects.
            - This waits till init because it's fairly intensive on the queries.


Other objects (for functionality) are as follows:

    * Display object
        - Has functions to manipulate the UI
            - replaces or gets the content of an element based on if new content is passed
            - The element specific methods are built on init
        > Turn the level info (in save_file) into HTML for the list.
            > Calls on a function that individuall builds list HTML li's
        > Changes the theme (if asked)
        > Highlights the selected level item
        > Can pop up transient notifications
        > Can change the content of individual "variable" holders in the HTML flow

        - This is the object that pretty much solely uses the `elements` object

    * Inputs object
        - Listens for button presses / keydown or whatever and calls the appropriate function
        - Also uses the `elements` object to attach event handlers
        - Listens for the following:
        > Pressing the "Change theme" button
            - Updates the save_file
            - Calls the display object's theme toggler
        > Pressing 'reset'
            // Should probably ask for certainty, but notifications system isn't implemented...
            - Calls the save_file's reset function
            - Calls 'reload' to refresh the page
        > Clicking a level link in the list of levels
            - Updates the save_file
            - Reset current score
            - Calls the display object's level switching function (gives it the level clicked on)
        > Clicking 'skip'
            - Calls the `game` object's skip function
        > Pressing enter inside the input bar
            - Calls the `game` object's checking function (gives it the value)
            - See below for everything else

    * Game object
        - Stores the major-system lookup object
        - Handles game logic such as:
            - Score calculation (current score and high score)
            - Number and Word generation
                - Relies on the save_file's format string
            - Number and Word checking
            - Updates the save_file with the above values


Initialization Routine
======================

The following actions must happend before the game is ready (IN THIS ORDER).

* `save_file` loads in the appdata from localstorage.
    - If nothing to load, then defaults are used and immediately saved in.
* The theme gets applied from appdata (defaults or otherwise).
* `elements` gets transformed into the DOM objects instead of just strings.
* Build an element-specific method for each member of `elements`
* The select menu is built and displayed.
* The current_level in appdata gets selected in the menu (visibly)
* The readout is initialized to the appropriate state
    - level => current_level
    - levelinfo => levels[current_level].info
    - highscore => levels[current_level].highscore
    - score => current_score  (should be zero, unless the browser crashed.)


Game Logic Flow
===============

* Generate the number in question
    - Pass in the level state parameters.
* User enters a word (and any number of other characters)
    - First time? Then record a timestamp as soon as keypress detected.
> User presses enter
    - Program detects the press
    - Grab the inputted value
    > Check if the inputted value is correct / works (must be in dictionary, sorry)
        1. If correct:
            * Update score
                - See main.js funciton
            * Update readout
            * Update level list
            - Add the word to the list of submitted words along with its timestamp.
            - If applicable, calculate the wpm for the last 5 words
            - If wpm for last 5 words is less than or equal to "pass score" then pass the stage
                - Pop up a little notification, and change the badge
            - Clear the input box
        2. If incorrect:
            - Pop up an "incorrect" notification.
            - Do nothing else (do not clear the input box)

